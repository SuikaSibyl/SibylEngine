#version 450
#extension GL_KHR_shader_subgroup_basic: require

#define ELEMENT_NUM 100000
#define BLOCK_SIZE 1024
#define WARP_PER_BLOCK BLOCK_SIZE/32
#define TILE_SIZE 2048
#define TILE_PER_BLOCK 1
#define ELEMENT_PER_BLOCK TILE_SIZE*TILE_PER_BLOCK
#define ACTIVE_BLOCK_NUM ((ELEMENT_NUM+ELEMENT_PER_BLOCK - 1)/ELEMENT_PER_BLOCK)
#define DIGITS 8
#define POSSIBLE_DIGIT_VALUE 2

#define NUM_BANKS 16
#define LOG_NUM_BANKS 4
#ifdef ZERO_BANK_CONFLICTS
#define CONFLICT_FREE_OFFSET(index) ((index) >> LOG_NUM_BANKS + (index) >> (2 * LOG_NUM_BANKS))
#else
#define CONFLICT_FREE_OFFSET(index) ((index) >> LOG_NUM_BANKS)
#endif

layout (local_size_x = 1024) in;

layout(push_constant) uniform constants {
    uint digitOffset;
} PushConstants;

// SIZE = ELEMENT_COUNT
layout(set = 0, binding = 0, std430) buffer restrict readonly InputKeys
{
    uint keys[];
};

layout(set = 0, binding = 1, std430) buffer restrict SortedIndex
{
    uint indices[];
};

// OffsetFromDigitStarts are global using decoupled look-back
// It is a 2-D buffer
// Here is an example for 4-way 16-bits parallel radix sorting
//           x-axis = tiles:
// y-axis =         0   1   2   3   4  ...  t
// possible     0  [0] [1] [2] [3] [4] ... [t]
// values       1  [.] [.] [.] [.] [.] ... [.]
// (bins)       2  [.] [.] [.] [.] [.] ... [.]
//              3  [.] [.] [.] [.] [.] ... [.]
layout(set = 0, binding = 2, std430) buffer volatile restrict OffsetFromDigitStartsAggregate
{
    uint aggregate[];
};
layout(set = 0, binding = 3, std430) buffer volatile restrict OffsetFromDigitStartsPrefix
{
    uint prefix[];
};
uint accessOffset2DArray(uint possible_value, uint workgroup)
{
    return possible_value + workgroup * POSSIBLE_DIGIT_VALUE;
}

// // Global Histograms are scanned for the whole-array.
// // It is a 2-D buffer
// // Here is an example for 4-way 16-bits parallel radix sorting
// //           x-axis = possible value:
// // y-axis =         0   1   2   3
// // digit offset 0  [0] [1] [2] [3]
// //              1  [4] [5] [6] [7]
// //              2  [8] [.] [.] [.]
// //              3  [.] [.] [.] [.]
// //              .   .   .   .   .
// //              7  [.] [.] [.] [.]
layout(set = 0, binding = 4, std430) buffer restrict readonly GlobalDigitHistogram
{
    uint gGlobalHistogram[];
};

uint getGlobalDigitHistogram(uint pass, uint digit_value)
{
    return gGlobalHistogram[pass*POSSIBLE_DIGIT_VALUE + digit_value];
}

layout(set = 0, binding = 5, std430) buffer restrict GlobalCounter
{
    uint gWorkgroupCounter;
    uint gDebugLogCounter;
};

layout(set = 0, binding = 6, std430) buffer restrict DebugInfo
{
    uint gDebugInfo[];
};

const uint already_prepared = 0x80000000;
const uint low_pass_mask = 0x7FFFFFFF;

shared uint shared_match_masks[WARP_PER_BLOCK][DIGITS]; // init with 0

// Use a local prefix sum to get aggregate value for this tile
// and also local prefix sum
void countAggregateValue()
{
    uint thid = gl_LocalInvocationID.x;
    uint warp_idx = gl_SubgroupID;

    // 1. warp digit prefix
    // - 1.1 warp-private digit histogram
    //atomicOr(shared_match_masks[warp_idx][digit], 1 << lane);
    // - 1.2 incremented by leader
    // - 1.3 add to rank
    subgroupBarrier();
    // 2. within thread block
    // - 2.1 exclusive prefix sum of warp digit count
    // - 2.2 add to rank
}

shared uint temp[TILE_SIZE + CONFLICT_FREE_OFFSET(TILE_SIZE)];
shared uint sharedWorkgroupID;
shared uint sharedExclusivePrefix;

void setTempRaw(uint idx, uint value)
{
    temp[idx+CONFLICT_FREE_OFFSET(idx)] = value;
}
uint getTempRaw(uint idx)
{
    return temp[idx+CONFLICT_FREE_OFFSET(idx)];
}

void main()
{
    uint thid = gl_LocalInvocationID.x;
    if(thid==0) // Fetch a workgroupID
    {
        sharedWorkgroupID = atomicAdd(gWorkgroupCounter, 1);
        if(sharedWorkgroupID+1==gl_NumWorkGroups.x) gWorkgroupCounter = 0;

        if(PushConstants.digitOffset==3)
        {
            uint debugIdx = atomicAdd(gDebugLogCounter, 1);
            gDebugInfo[debugIdx] = 
                sharedWorkgroupID;
        }
    }
    barrier();
    uint workgroupID = sharedWorkgroupID;
    // Thread Info
    uint wgid = workgroupID / POSSIBLE_DIGIT_VALUE;
    uint target_digit = workgroupID % POSSIBLE_DIGIT_VALUE;
    // Element to deal with
    uint ai = thid;
    uint bi = thid + (TILE_SIZE/2);
    uint bankOffsetA = CONFLICT_FREE_OFFSET(ai); 
    uint bankOffsetB = CONFLICT_FREE_OFFSET(bi);
    uint workgroup_element_offset = wgid*TILE_SIZE*TILE_PER_BLOCK;
    // Init workgroup shared memory
    temp[ai+bankOffsetA] = 0;
    temp[bi+bankOffsetB] = 0;
    barrier();
    
    // Pass Info
    uint mask = 0x00000001 << PushConstants.digitOffset;
    uint in_array = PushConstants.digitOffset % 2;
    uint out_array = 1 -in_array;
    // load keys into shared memory
    // each thread handle 2 keys
    uint offseted_ai = workgroup_element_offset + ai;
    bool is_target_ai = false;
    if(offseted_ai < ELEMENT_NUM)
    {
        uint passMask_a = keys[indices[offseted_ai + ELEMENT_NUM*in_array]];
        passMask_a = (passMask_a & mask) >> PushConstants.digitOffset;
        is_target_ai = (passMask_a == target_digit);
        temp[ai+bankOffsetA] = is_target_ai ? 1 : 0;
    }
    uint offseted_bi = workgroup_element_offset + bi;
    bool is_target_bi = false;
    if(offseted_bi < ELEMENT_NUM)
    {
        uint passMask_b = keys[indices[offseted_bi + ELEMENT_NUM*in_array]];
        passMask_b = (passMask_b & mask) >> PushConstants.digitOffset;
        is_target_bi = (passMask_b == target_digit);
        temp[bi+bankOffsetB] = is_target_bi ? 1 : 0;        
    }
    
    // build sum in place up the tree 
    uint offset = 1;
    for (int d = TILE_SIZE>>1; d>0; d>>=1)
    {
        barrier();
        if(thid < d)
        {
            uint ai = offset*(2*thid+1)-1;
            uint bi = offset*(2*thid+2)-1;
            uint bankOffsetA = CONFLICT_FREE_OFFSET(ai); 
            uint bankOffsetB = CONFLICT_FREE_OFFSET(bi);
            temp[bi+bankOffsetB] += temp[ai+bankOffsetA];
        }
        offset *= 2;
    }

    barrier();
    uint workgroupAggregate = temp[TILE_SIZE-1 + CONFLICT_FREE_OFFSET(TILE_SIZE-1)];
    
    uint tmp_id = accessOffset2DArray(target_digit, wgid);
    if (thid == 0)
    {
        aggregate[tmp_id] = workgroupAggregate | already_prepared;
        memoryBarrierBuffer();

        // clear the last element
        uint exclusive_prefix = 0;
        for(int i = int(wgid)-1; i >= 0; i--)
        {
            uint local_tmp_id = accessOffset2DArray(target_digit, i);
            if((prefix[local_tmp_id] & already_prepared) != 0)
            {
                exclusive_prefix += prefix[local_tmp_id] & low_pass_mask;
                break;
            }
            else
            {
                // stall until aggregate is prepared
                while((aggregate[local_tmp_id] & already_prepared)==0){}
                exclusive_prefix += aggregate[local_tmp_id] & low_pass_mask;
            }
        }
        sharedExclusivePrefix = exclusive_prefix;
        prefix[tmp_id] = (exclusive_prefix + workgroupAggregate) | already_prepared;
        memoryBarrierBuffer();
        temp[TILE_SIZE-1 + CONFLICT_FREE_OFFSET(TILE_SIZE-1)] = 0;
    }

    for (int d = 1; d < TILE_SIZE; d *= 2) // traverse down tree & build scan
    {
        offset >>= 1;
        barrier();
        if (thid < d)
        {
            uint ai = offset*(2*thid+1)-1;
            uint bi = offset*(2*thid+2)-1;
            ai += CONFLICT_FREE_OFFSET(ai); 
            bi += CONFLICT_FREE_OFFSET(bi);
            uint t = temp[ai];
            temp[ai] = temp[bi];
            temp[bi] += t & low_pass_mask;
        }
    }
    
    barrier();
    uint exclusive_prefix = sharedExclusivePrefix;
    
    if(is_target_ai)
    {
        uint target_pos_ai = (temp[ai+bankOffsetA]&low_pass_mask) + exclusive_prefix + getGlobalDigitHistogram(PushConstants.digitOffset, target_digit);
        uint value = indices[offseted_ai + ELEMENT_NUM*in_array];
        indices[target_pos_ai + ELEMENT_NUM*out_array] = value;
    }
    if(is_target_bi)
    {
        uint target_pos_bi = (temp[bi+bankOffsetB]&low_pass_mask) + exclusive_prefix + getGlobalDigitHistogram(PushConstants.digitOffset, target_digit);
        uint value = indices[offseted_bi + ELEMENT_NUM*in_array];
        indices[target_pos_bi + ELEMENT_NUM*out_array] = value;
    }

    barrier();
    
    // clean up inter-workgroup info
    if (thid == 0 && wgid>0)
    {
        uint prev_wgid = wgid - 1;
        uint prev_prefix_id = accessOffset2DArray(target_digit, prev_wgid);
        aggregate[prev_prefix_id] = 0;
        prefix[prev_prefix_id] = 0;

        if(wgid == (ACTIVE_BLOCK_NUM-1))
        {
            aggregate[tmp_id] = 0;
            prefix[tmp_id] = 0;
        }
    }
}