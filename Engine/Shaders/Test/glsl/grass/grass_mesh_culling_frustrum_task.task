#version 450
#extension GL_NV_mesh_shader: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_KHR_shader_subgroup_basic: require
#extension GL_KHR_shader_subgroup_ballot: require
#extension GL_KHR_shader_subgroup_shuffle: require
#extension GL_KHR_shader_subgroup_shuffle_relative: require

#define GROUP_SIZE 32

layout(push_constant) uniform PushConstantObject {
    vec2 screen_size;
} PushConstants;

struct CullingInfo
{
    vec4 aabb_xy_wh;
    vec4 min_max_depth;
};
layout(set = 0, binding = 6, std430) buffer restrict CullingInfos
{ CullingInfo cullingInfos[]; };

layout ( binding = 7 ) uniform sampler2D depthImage;

// Size of the payloads. The AS payload should preferably stay below 108 bytes, but if that is not possible, then keep it at least under 236 bytes.
// Number of invocations of the amplification shader.
// Number of mesh shaders emitted by the respective amplification shader (amplification rate).

float nrand()
{
  float n = gl_GlobalInvocationID.x;
	return fract(sin(91.2228 * n)* 43758.5453);
}

bool cullCluster(in CullingInfo cullingInfo, out bool needLoD, out bool doRenderLoDMin, out float throwPosibility)
{
  // xmin ymin xmax ymax
  needLoD = false;
  doRenderLoDMin = false;
  if(cullingInfo.aabb_xy_wh.x==99999)
  {
    return true;
  }
  if(cullingInfo.aabb_xy_wh.x >= 1 || cullingInfo.aabb_xy_wh.y >= 1 || cullingInfo.aabb_xy_wh.z <= 0 || cullingInfo.aabb_xy_wh.w <= 0 || cullingInfo.min_max_depth.y < 0.1)
    return false;

  float width = (cullingInfo.aabb_xy_wh.z - cullingInfo.aabb_xy_wh.x) * PushConstants.screen_size.x;
  float height = (cullingInfo.aabb_xy_wh.w - cullingInfo.aabb_xy_wh.y) * PushConstants.screen_size.y;
  if(max(width, height)<1.0f)
    return false;

  uint partilets_idx = gl_GlobalInvocationID.x;
  if(cullingInfo.min_max_depth.x > 0.1)
  {
    float depth_proj = cullingInfo.min_max_depth.x;
    depth_proj = 1.00004005 - 0.200004011 / depth_proj; // Z : [-1,1]
    depth_proj = (depth_proj + 1) /2;
    vec2 uv = vec2(
        (cullingInfos[partilets_idx].aabb_xy_wh.x + cullingInfos[partilets_idx].aabb_xy_wh.z) / 2, 
        (cullingInfos[partilets_idx].aabb_xy_wh.y + cullingInfos[partilets_idx].aabb_xy_wh.w) / 2);

    float width = (cullingInfos[partilets_idx].aabb_xy_wh.z - cullingInfos[partilets_idx].aabb_xy_wh.x) * PushConstants.screen_size.x;
    float height = (cullingInfos[partilets_idx].aabb_xy_wh.w - cullingInfos[partilets_idx].aabb_xy_wh.y) * PushConstants.screen_size.y;

    if(width > 10 || height > 10)
    {
      needLoD = true;
    }
    if(width <= 4 && height <= 4)
    {
      doRenderLoDMin = true;
      throwPosibility = clamp(0.3 + ((4 - min(width, height)) / 4), 0, 1);
      // throwPosibility = 1 - throwPosibility * throwPosibility;
    }
    if(width>PushConstants.screen_size.x || height > PushConstants.screen_size.y)
    {

    }
    else
    {
        float level = ceil(log2(max(ceil(width), ceil(height))));
        float depth = 1 - textureLod(depthImage, uv, level).x;
        //float depth_in_linear = 0.200004011 / (1.00004005 - (2*depth-1));

        // if(depth_proj > depth) return false;
    }

  }
  return true;
}

taskNV out Task {
  uint      baseID;
  uint8_t   subIDs[65];
} OUT;

layout(local_size_x=32) in;
void main()
{
  uint valid_meshlets_count = (65536 + 15) / 16;
  if(gl_GlobalInvocationID.x >= valid_meshlets_count) return;

  CullingInfo cullingInfo = cullingInfos[gl_GlobalInvocationID.x];

  bool  doRenderLoD = false;
  bool  doRenderLoDMin = false;
  float throwPosibility = -1;
  bool  doRender    = cullCluster(cullingInfo, doRenderLoD, doRenderLoDMin, throwPosibility);

  doRenderLoDMin = doRenderLoDMin && doRender;
  if(doRenderLoDMin)
  {
    doRender = false;
    doRenderLoDMin = (nrand() > throwPosibility) ? true : false;
  }
  doRenderLoD = doRenderLoD && doRender;
  
  uvec4 vote        = subgroupBallot(doRender);
  uint  numMeshlets = subgroupBallotBitCount(vote);
  OUT.baseID = gl_WorkGroupID.x * GROUP_SIZE;
  uint taskCount = 0;

  uint idxOffset = subgroupBallotExclusiveBitCount(vote);
  if (doRender)
  {
    OUT.subIDs[idxOffset] = uint8_t(gl_LocalInvocationID.x);
  }
  taskCount += numMeshlets;
  
  if(numMeshlets != 0)
  {
    uvec4 voteLoD        = subgroupBallot(doRenderLoD);
    uint  numMeshletsLoD = subgroupBallotBitCount(voteLoD);

    uint idxOffsetLoD = subgroupBallotExclusiveBitCount(voteLoD);
    if (doRender && doRenderLoD)
    {
      OUT.subIDs[idxOffset] |= uint8_t(64);
      OUT.subIDs[taskCount + idxOffsetLoD] = uint8_t(gl_LocalInvocationID.x | 192);
    }

    taskCount += numMeshletsLoD;
  }
  
  if(numMeshlets != 32)
  {
    // min LoD problem
    uvec4 voteMin        = subgroupBallot(doRenderLoDMin);
    uint  numMeshletsMin = subgroupBallotBitCount(voteMin);
    uint idxOffsetMin = subgroupBallotExclusiveBitCount(voteMin);

    if(numMeshletsMin > 0)
    {
      uint minMeshGroupNum = (numMeshletsMin + 15) / 16;
        
      if(doRenderLoDMin)
      {
        OUT.subIDs[taskCount + 2 + idxOffsetMin] = uint8_t(gl_LocalInvocationID.x | 128);
      }

      if (gl_LocalInvocationID.x == 0)  
      {
        OUT.subIDs[taskCount + 0] = uint8_t(min(numMeshletsMin, 16) | 128);
        OUT.subIDs[taskCount + 1] = uint8_t(numMeshletsMin | 128);
      }
      taskCount+=minMeshGroupNum;
    }
  }

  if (gl_LocalInvocationID.x == 0) {
    gl_TaskCountNV = taskCount;
  }
}