#version 450
#extension GL_KHR_shader_subgroup_basic: require
#extension GL_KHR_shader_subgroup_ballot: require
#extension GL_KHR_shader_subgroup_shuffle: require
#extension GL_KHR_shader_subgroup_shuffle_relative: require
#extension GL_KHR_shader_subgroup_clustered: require

#define CAMERA_NEAR 0.1

layout(push_constant) uniform PushConstantObject {
    vec2 screen_size;
} PushConstants;

layout(binding = 0) uniform PerViewUniformBuffer {
    mat4 view;
    mat4 proj;
    vec4 cameraPos;
} view_ubo;

layout(set = 0, binding = 1, std430) buffer ParticlesPosLifetime
{ vec4 particle_pos_lifetime[]; };

layout(set = 0, binding = 2, std430) buffer ParticlesVelocityMass
{ vec4 particle_vel_mass[]; };

layout(set = 0, binding = 3, std430) buffer restrict DoubleBufferedIndices
{ uint indices[]; };

struct CullingInfo
{
    vec4 aabb_xy_wh;
    vec4 min_max_depth;
};
layout(set = 0, binding = 4, std430) buffer restrict CullingInfos
{ CullingInfo cullingInfos[]; };

struct Counter
{
    uint aliveCount;
    uint deadCount;
    uint emitCount;
    uint drawCount;
    uint maxCount;
};
layout(set = 0, binding = 5, std430) buffer Counters
{ Counter counter[]; };

#define THREADS_PER_BLOCK 32
#define WARPS_PER_BLOCK (THREADS_PER_BLOCK / 32)

layout (local_size_x = THREADS_PER_BLOCK) in;

const float bounding_sphere_radius = 0.5 * 0.2 * 0.76966;

bool projectSphere(vec3 center, float radius, float znear, float p00, float p11, out vec4 aabb)
{
    // culled by near plane
    if(center.z <= znear - radius)
    {
        aabb = vec4(99999, 99999, -99999, -99999);
        return false;
    }

    vec2 c_xz = center.xz;
    vec2 vx = vec2(sqrt(dot(c_xz,c_xz)-radius*radius), radius);
    vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * c_xz;
    vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * c_xz;

    vec2 c_yz = center.yz;
    vec2 vy = vec2(sqrt(dot(c_yz,c_yz)-radius*radius), radius);
    vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * c_yz;
    vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * c_yz;

    aabb = vec4(minx.x/minx.y*p00, miny.x/miny.y*p11, maxx.x/maxx.y*p00, maxy.x/maxy.y*p11);
    aabb = aabb * vec4(0.5f,  -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space
    return true;
}

mat4 billboardAlongVelocity(vec3 velocity, vec3 cameraPos)
{
    vec3 up = - normalize(velocity);
    vec3 right = normalize(cross(up, -normalize(cameraPos)));
    vec3 look = normalize(cross(right, up));
    return mat4(
        right.x,right.y,right.z,0,
        up.x,up.y,up.z,0,
        look.x,look.y,look.z,0,
        0,0,0,1);
}
vec3 getScale(mat4 matrix)
{
    return vec3(1,1,1);
}
float speed_y_curve(float i)
{
    if(i > 1) return 0.769;
    return 0.769 * i;
}

// Constant Billboard Data 
const vec3 vertices[4] = {
    vec3(-0.5f, -0.5f, +0.0f),
    vec3(+0.5f, -0.5f, +0.0f),
    vec3(+0.5f, +0.5f, +0.0f),
    vec3(-0.5f, +0.5f, +0.0f),
};

void getBoundingInfoDumb(out vec2 bounding_min, out vec2 bounding_max)
{
    uint idx = gl_GlobalInvocationID.x;
    uint particle_idx = indices[idx];
    vec4 vel_mass = particle_vel_mass[particle_idx];
    vec4 pos_lifetime = particle_pos_lifetime[particle_idx];
    mat4 billboardMat = billboardAlongVelocity(vec3(0,1,0), view_ubo.cameraPos.xyz - pos_lifetime.xyz);

    vec4 modelPosition[4];
    vec4 projPosition[4];

    for(int i=0;i<4;i++)
    {
        modelPosition[i] = billboardMat * vec4(vertices[i] * vec3(0.05,0.05,0.05) ,1.0);
        projPosition[i] = view_ubo.proj * view_ubo.view * (vec4(modelPosition[i].xyz + pos_lifetime.xyz, 1.0));
        projPosition[i].xy /= abs(projPosition[i].w);
    }

    bounding_min = min(min(projPosition[0].xy,projPosition[1].xy),min(projPosition[2].xy,projPosition[3].xy));
    bounding_max = max(max(projPosition[0].xy,projPosition[1].xy),max(projPosition[2].xy,projPosition[3].xy));

    bounding_min = bounding_min*vec2(0.5) + vec2(0.5);
    bounding_max = bounding_max*vec2(0.5) + vec2(0.5);
}

void main()
{    
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= counter[0].aliveCount) return;

    // uint particle_idx = indices[idx];
    // vec4 particle_pos = particle_pos_lifetime[particle_idx];

    // // transform center to view space
    // vec4 view_space_pos = view_ubo.view * vec4(particle_pos.rgb, 1.0);
    // vec4 screen_space_single_sphere_aabb;
    // projectSphere(view_space_pos.xyz, bounding_sphere_radius, CAMERA_NEAR,
    //     view_ubo.proj[0][0], view_ubo.proj[1][1], screen_space_single_sphere_aabb);

    // vec2 bounding_min = screen_space_single_sphere_aabb.xy;
    // vec2 bounding_max = screen_space_single_sphere_aabb.zw;

    vec2 bounding_min;
    vec2 bounding_max;
    getBoundingInfoDumb(bounding_min, bounding_max);

    vec2 bounding_min_cluster = subgroupClusteredMin(bounding_min, 16);
    vec2 bounding_max_cluster = subgroupClusteredMax(bounding_max, 16);

    if(gl_SubgroupInvocationID == 0 || gl_SubgroupInvocationID == 16)
    {
        uint meshlets_idx = gl_WorkGroupID.x*2*WARPS_PER_BLOCK + gl_SubgroupID*2 + gl_SubgroupInvocationID/16;
        CullingInfo info;
        info.aabb_xy_wh = vec4(bounding_min_cluster, bounding_max_cluster);
        info.min_max_depth = vec4(0,0, (bounding_max_cluster.xy-bounding_min_cluster.xy)*PushConstants.screen_size);
        cullingInfos[meshlets_idx] = info;
    }
}