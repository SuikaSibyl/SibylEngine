 #version 450

layout(set = 0, binding = 0, std430) buffer ParticlesPosLifetime
{ vec4 particle_pos_lifetime[]; };

layout(set = 0, binding = 1, std430) buffer ParticlesVelocityMass
{ vec4 particle_vel_mass[]; };

struct Counter
{
    uint aliveCount;
    uint deadCount;
    uint emitCount;
    uint drawCount;
    uint maxCount;
};
layout(set = 0, binding = 2, std430) buffer Counters
{
    Counter counter[];
} counter;


layout(set = 0, binding = 3, std430) buffer LiveIndexBuffer
{
    uint[] indices;
} livePool;

layout(set = 0, binding = 4, std430) buffer DeadIndexBuffer
{
    uint[] indices;
} deadPool;

struct DrawIndexedIndirect
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(set = 0, binding = 5, std430) buffer IndirectDrawBuffer
{
    DrawIndexedIndirect[] content;
} IndirectBuffer;

layout (local_size_x =512) in;

void main()
{
    if(gl_GlobalInvocationID.x >= counter.counter[0].aliveCount) return;

    uint idx = gl_GlobalInvocationID.x;

    if(idx==0)
    {
        if(counter.counter[0].deadCount > counter.counter[0].maxCount)
            counter.counter[0].deadCount = 0;
    }

    memoryBarrier();
    barrier();

    vec4 pos_lifetime = particle_pos_lifetime[idx];
    vec4 vel_mass = particle_vel_mass[idx];
    float ground_height = 0;

    // update velocity
    // - linear drag
    float mass = vel_mass.w;
    vec3 a = - 2 * normalize(vel_mass.xyz) * (length(vel_mass.xyz));;
    // - gravity
    if(pos_lifetime.y - ground_height > 0.02)
        a += vec3(0, -9.81, 0);
    vel_mass.xyz += 0.02 * a / mass;

    // update position
    pos_lifetime.xyz = pos_lifetime.xyz + vel_mass.xyz * 0.02;

    // collision handling
    if(pos_lifetime.y < ground_height)
    {
        vec3 compensate = vel_mass.xyz * ((ground_height - pos_lifetime.y) / vel_mass.y);
        pos_lifetime.xyz += compensate;
        pos_lifetime.y = ground_height;
        vel_mass.xyz += - 2 * vec3(0,1,0) * dot(vel_mass.xyz, vec3(0,1,0));
        vel_mass.xyz *= 0.5;
        // todo: roughness to randomize return velocity
    }

    uint lifetick_pack = floatBitsToUint(pos_lifetime.w);
    uint lifetick = lifetick_pack & 0xFFFF;
    lifetick -= 1;
    if(lifetick == 0)
    {
        uint deadCount = atomicAdd(counter.counter[0].deadCount, 1);
        deadPool.indices[deadCount] = idx;
        uint aliveCount = atomicAdd(counter.counter[0].aliveCount, -1);
        livePool.indices[idx] = livePool.indices[aliveCount-1];
    }
    pos_lifetime.w = uintBitsToFloat(lifetick_pack - 1);
    particle_pos_lifetime[idx] = pos_lifetime;
    particle_vel_mass[idx] = vel_mass;

    memoryBarrier();
    barrier();

    if(idx==0)
    {
        uint aliveCount = atomicAdd(counter.counter[0].aliveCount, 0);
        IndirectBuffer.content[0].instanceCount = aliveCount;
    }
}
