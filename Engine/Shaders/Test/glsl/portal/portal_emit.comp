 #version 450

layout(push_constant) uniform constants {
    mat4 offset;
    uint emitCount;
    float time;
} PushConstants;

layout(set = 0, binding = 0, std430) buffer ParticlesPosLifetime
{ vec4 particle_pos_lifetime[]; };

layout(set = 0, binding = 1, std430) buffer ParticlesVelocityMass
{ vec4 particle_vel_mass[]; };

layout(set = 0, binding = 2, std430) buffer ParticlesColor
{ vec4 particle_color[]; };

struct Counter
{
    uint aliveCount;
    uint deadCount;
    uint emitCount;
    uint drawCount;
    uint maxCount;
};
layout(set = 0, binding = 3, std430) buffer Counters
{
    Counter counter[];
} counter;


layout(set = 0, binding = 4, std430) buffer LiveIndexBuffer
{
    uint[] indices;
} livePool;

layout(set = 0, binding = 5, std430) buffer DeadIndexBuffer
{
    uint[] indices;
} deadPool;

layout(set = 0, binding = 6, std430) buffer EmitterBuffer
{
    vec4[] pos;
} emitterSamples;

layout(binding = 7) uniform sampler2D texSampler;

//----------------------------------------------------------------------------------------
// RANDOM 
//----------------------------------------------------------------------------------------
//note: uniformly distributed, normalized rand, [0;1[
float nrand( float n )
{
	return fract(sin(91.2228 * n)* 43758.5453);
}
float nrand( vec2 n )
{
	return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}

float hash(float n) { return fract(sin(n) * 1e4); }
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
//  3 out, 1 in...
vec3 hash31(float p)
{
   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
   p3 += dot(p3, p3.yzx+33.33);
   return fract((p3.xxy+p3.yzz)*p3.zyx); 
}
///  3 out, 2 in...
vec3 hash32(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy+p3.yzz)*p3.zyx);
}

//----------------------------------------------------------------------------------------
// Utility 
//----------------------------------------------------------------------------------------
float lerp(float x, float y, float s)
{
    return x + s * (y-x);
}

float curve_velocity(float time)
{   
    if(time < 0.669) return time * 0.687593423;
    else if(time < 0.822) return 0.46 + (time - 0.669) * 7.79738562;
    else return 1.653;
}

float randPerThread(float seed)
{
    return nrand(gl_GlobalInvocationID.x + seed * fract(PushConstants.time));
}

mat3 getRotation(mat4 mat)
{
    mat3 no_translation = mat3(mat);
    vec3 scale = vec3(length(mat[0].rgb),length(mat[1].rgb),length(mat[2].rgb));
    no_translation[0] /= scale.x;
    no_translation[1] /= scale.y;
    no_translation[2] /= scale.z;
    return no_translation;
}

float remapWithClamp(float i, float old_range_min, float old_range_max, float new_range_min, float new_range_max)
{
    float clamped = clamp(i, old_range_min, old_range_max);
    float uniformed = (clamped - old_range_min) / (old_range_max - old_range_min);
    return new_range_min + uniformed * (new_range_max - new_range_min);
}

//----------------------------------------------------------------------------------------
// Main 
//----------------------------------------------------------------------------------------
struct Particle
{
    vec4 pos_lifetime;
    vec4 vel_mass;
    vec4 color;
};

layout (local_size_x =512) in;
void main()
{
    if(gl_GlobalInvocationID.x >= PushConstants.emitCount) return;

    // Move a dead particle to alive
    uint deadCount = atomicAdd(counter.counter[0].deadCount, -1);
    if(deadCount == 0 || deadCount > counter.counter[0].maxCount) return; // If no space is available
    
    Particle new_particle;
    // ========================================================================
    // Time for init a new particle
    // ========================================================================
    // init the particle on a Torus
    float major_radius = 1;
    float minor_radius = 1;
    uint sample_idx= int(1024 * randPerThread(0.2)) % 1024;
    vec3 particle_to_center = emitterSamples.pos[sample_idx].xyz;
    float pos_rotation_angle = 0.2 * randPerThread(0.3);
    float pos_cos_ra = cos(pos_rotation_angle);
    float pos_sin_ra = sin(pos_rotation_angle);
    mat4 pos_rotation_matrix = mat4(
        +pos_cos_ra, +pos_sin_ra, 0 , 0,
        -pos_sin_ra, +pos_cos_ra, 0 , 0,
        0,       0,       1 , 0,
        0,       0,       0 , 1
    );
    particle_to_center = (pos_rotation_matrix * vec4(particle_to_center, 1.0)).xyz;

    vec3 pos_offset = vec3(PushConstants.offset[3].rgb);
    new_particle.pos_lifetime.xyz = particle_to_center.xyz + pos_offset;

    // # Height Mask
    // We generate a (0..1) mask based particle elevation.
    // It is then used to categorize particles and 
    // to cancel turbulence noise for particles close to the ground.
    float height_mask = (clamp(new_particle.pos_lifetime.y, 0.2, 0.8) - 0.2) / 0.6;
    // # Categorizing particles
    // We are categorizing particles in two groups: core sparks and travelling sparks.
    // Based on a 0.05 probability. This will affect the lifetime.
    // Also, for the travelling sparks, we use the height mask to scale their lifetime up to 5 times 
    // for particles close to the ground.
    float rand_for_categorizing = randPerThread(0.4);
    float smaller_one = lerp(rand_for_categorizing, 0.4, 0.9);
    float larger_one = lerp(rand_for_categorizing, 0.9, 1.8);
    float remaped_heightmask = larger_one * remapWithClamp(height_mask,0,1,2.5,1);
    float rand_for_lifetime = randPerThread(0.5);
    // Set lifetime
    float lifetime = (rand_for_lifetime < lerp(height_mask, 0.15, 0.01)) ? remaped_heightmask : smaller_one;
    uint lifetick_count = uint(lifetime / 0.02);
    lifetick_count |= lifetick_count << 16;
    new_particle.pos_lifetime.w = uintBitsToFloat(lifetick_count);

    // Pulse rotation mask
    float total_time = PushConstants.time * 0.001;
    float angle_on_torus = total_time * -30 + atan(particle_to_center.y, particle_to_center.x);
    float rotation_mask = mod(angle_on_torus, 6.283185) / 6.283185;
    float brightness = texture(texSampler, vec2((0.5 + rotation_mask * 127)/128, 0.25)).r * 3.2;
    // float brightness = rotation_mask < 0.672 ? 0.1 : 3.2;
    

    // determine speed
    vec3 tangent = normalize(cross(vec3(0,0,1), particle_to_center));
    tangent = 6 * tangent * randPerThread(0.6);
    float rotation_angle = 0.2 * randPerThread(0.7);
    float cos_ra = cos(rotation_angle);
    float sin_ra = sin(rotation_angle);
    mat4 rotation_matrix = mat4(
        +cos_ra, +sin_ra, 0 , 0,
        -sin_ra, +cos_ra, 0 , 0,
        0,       0,       1 , 0,
        0,       0,       0 , 1
    );
    tangent = (rotation_matrix * vec4(tangent, 1.0)).xyz;
    tangent += particle_to_center * vec3(0,0,32);
    // extra component
    tangent *= curve_velocity(rotation_mask) * (0.8 + 1.2 * randPerThread(0.8));
    new_particle.vel_mass.xyz = (tangent);
    // Set Mass Random Uniform [0.6, 1.2]
    new_particle.vel_mass.w = 0.6 + 0.6 * randPerThread(0.9);

    // Set Color
    new_particle.color = vec4(brightness,brightness,brightness,1);

    mat3 rotation = getRotation(PushConstants.offset);
    new_particle.pos_lifetime.xyz = rotation * particle_to_center.xyz + pos_offset;
    new_particle.vel_mass.xyz = rotation * new_particle.vel_mass.xyz;

    // ========================================================================
    // Custom Part Over
    // ========================================================================
    // write new particle
    uint newParticleIdx = deadPool.indices[deadCount-1];
    particle_pos_lifetime[newParticleIdx] = new_particle.pos_lifetime;
    particle_vel_mass[newParticleIdx] = new_particle.vel_mass;
    particle_color[newParticleIdx] = new_particle.color;
    // add the new particle idx to live pool
    uint aliveCount = atomicAdd(counter.counter[0].aliveCount, 1);
    livePool.indices[aliveCount] = newParticleIdx;
}
