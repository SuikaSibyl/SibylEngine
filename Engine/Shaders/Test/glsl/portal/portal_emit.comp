 #version 450

layout(push_constant) uniform constants {
    uint emitCount;
    float time;
    float offset_x;
    float offset_y;
} PushConstants;

struct Particle
{
    vec4 pos;
    vec4 vel;
};

layout(set = 0, binding = 0, std430) buffer Particles
{
    Particle particle[];
} particles;

struct Counter
{
    uint aliveCount;
    uint deadCount;
    uint emitCount;
    uint drawCount;
    uint maxCount;
};
layout(set = 0, binding = 1, std430) buffer Counters
{
    Counter counter[];
} counter;


layout(set = 0, binding = 2, std430) buffer LiveIndexBuffer
{
    uint[] indices;
} livePool;

layout(set = 0, binding = 3, std430) buffer DeadIndexBuffer
{
    uint[] indices;
} deadPool;

// RANDOM 
//note: uniformly distributed, normalized rand, [0;1[
float nrand( float n )
{
	return fract(sin(91.2228 * n)* 43758.5453);
}
float nrand( vec2 n )
{
	return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}

float hash(float n) { return fract(sin(n) * 1e4); }
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
//  3 out, 1 in...
vec3 hash31(float p)
{
   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
   p3 += dot(p3, p3.yzx+33.33);
   return fract((p3.xxy+p3.yzz)*p3.zyx); 
}
//----------------------------------------------------------------------------------------
///  3 out, 2 in...
vec3 hash32(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy+p3.yzz)*p3.zyx);
}

float lerp(float x, float y, float s)
{
    return x + s * (y-x);
}

float curve_velocity(float time)
{   
    if(time < 0.669) return time * 0.687593423;
    else if(time < 0.822) return 0.46 + (time - 0.669) * 7.79738562;
    else return 1.653;
}

layout (local_size_x =512) in;
void main()
{
    if(gl_GlobalInvocationID.x >= PushConstants.emitCount) return;

    // Move a dead particle to alive
    if(counter.counter[0].deadCount==0) return;
    uint deadCount = atomicAdd(counter.counter[0].deadCount, -1);
    if(deadCount <= 1 || deadCount > counter.counter[0].maxCount) return; // If no space is available

    Particle new_particle;
    // init
    float sphere_radius = 1;
    float theta = 3.1415926 * 2 * nrand(vec2(gl_GlobalInvocationID.x + 0.7 * fract(PushConstants.time), fract(PushConstants.time)));
    vec3 particle_to_center = sphere_radius * vec3(cos(theta), sin(theta), 0);
    new_particle.pos.xy = particle_to_center.xy + vec2(PushConstants.offset_x, PushConstants.offset_y);
    new_particle.pos.z = 0;

    // determine lifetime
    float rand_lifetime = nrand(gl_GlobalInvocationID.x + 0.7 * fract(PushConstants.time));
    float lifetime = lerp(0.4, 0.9, rand_lifetime);
    new_particle.pos.w = lifetime / 0.02;

    // determine speed
    vec3 tangent = normalize(cross(vec3(0,0,1), particle_to_center));
    tangent = 6 * tangent * nrand(gl_GlobalInvocationID.x + 0.3 * fract(PushConstants.time));
    float rotation_angle = 0.2 * nrand(gl_GlobalInvocationID.x + 0.1 * fract(PushConstants.time));
    float cos_ra = cos(rotation_angle);
    float sin_ra = sin(rotation_angle);
    mat4 rotation_matrix = mat4(
        +cos_ra, +sin_ra, 0 , 0,
        -sin_ra, +cos_ra, 0 , 0,
        0,       0,       1 , 0,
        0,       0,       0 , 1
    );
    tangent = (rotation_matrix * vec4(tangent, 1.0)).xyz;
    // extra component
    float pulse_rotation_mask = mod(theta + (-3)*PushConstants.time, 6.283185) / 6.283185;
    tangent *= curve_velocity(pulse_rotation_mask) * (0.8 + 1.2 * nrand(gl_GlobalInvocationID.x + 0.1 * fract(PushConstants.time)));
    new_particle.vel = vec4(tangent, 0.6 + 0.6 * nrand(gl_GlobalInvocationID.x + 0.3 * fract(PushConstants.time)));


    // write new particle
    uint newParticleIdx = deadPool.indices[deadCount-1];
    particles.particle[newParticleIdx] = new_particle;
    // add the new particle idx to live pool
    uint aliveCount = atomicAdd(counter.counter[0].aliveCount, 1);
    livePool.indices[aliveCount] = newParticleIdx;
}
