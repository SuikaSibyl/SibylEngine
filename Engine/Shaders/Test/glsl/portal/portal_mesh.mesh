#version 450
#extension GL_NV_mesh_shader: require

#define LOCAL_SIZE 16
layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = LOCAL_SIZE * 4, max_primitives = LOCAL_SIZE * 2) out;

layout(binding = 0) uniform UniformBufferObject {
    vec4 cameraPos;
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

struct Particle
{
    vec4 pos;
    vec4 vel;
    vec4 color;
    vec4 ext;
};
layout(set = 0, binding = 2, std430) buffer Particles
{
    Particle particle[];
} particles;

layout(binding = 3) uniform sampler2D texSampler;

layout(set = 0, binding = 4, std430) buffer LiveIndexBuffer
{
    uint[] indices;
} livePool;

struct DrawIndexedIndirect
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};
layout(set = 0, binding = 5, std430) buffer DrawIndexedIndirects
{
    DrawIndexedIndirect content[];
} drawIndirect;

layout (location = 0) out PerVertexData
{
  vec2 fragTexCoord;
} v_out[];   // [max_vertices]

layout (location = 1) perprimitiveNV out PerPrimitiveData
{
  vec3 color;
} per_primitive_out[];   // [max_vertices]

// Constant Billboard Data 
const vec3 vertices[4] = {
    vec3(-0.5f, -0.5f, +0.0f),
    vec3(+0.5f, -0.5f, +0.0f),
    vec3(+0.5f, +0.5f, +0.0f),
    vec3(+0.5f, +0.5f, +0.0f),
};
const vec2 uvs[4] = {
    vec2(1.0f, 0.0f),
    vec2(0.0f, 0.0f),
    vec2(0.0f, 1.0f),
    vec2(1.0f, 1.0f),
};
const uint indices[6] = { 0, 1, 2, 2, 3, 0 };

// Billboard Utilities
mat4 billboardTowardCameraPlane(vec3 cameraPos)
{
    vec3 look = - normalize(cameraPos);
    vec3 right = normalize(cross(vec3(0,1,0), look));
    vec3 up = normalize(cross(right, look));
    return mat4(
        right.x,right.y,right.z,0,
        up.x,up.y,up.z,0,
        look.x,look.y,look.z,0,
        0,0,0,1);
}

mat4 billboardAlongVelocity(vec3 velocity, vec3 cameraPos)
{
    vec3 up = - normalize(velocity);
    vec3 right = normalize(cross(up, normalize(cameraPos)));
    vec3 look = normalize(cross(right, up));
    return mat4(
        right.x,right.y,right.z,0,
        up.x,up.y,up.z,0,
        look.x,look.y,look.z,0,
        0,0,0,1);
}

float speed_y_curve(float i)
{
    if(i > 1) return 0.769;
    return 0.769 * i;
}

void main()
{    
    uint idx = gl_GlobalInvocationID.x;
    uint thread_id = gl_LocalInvocationID.x;

    if(idx >= drawIndirect.content[0].instanceCount) return;

    // Each thread handle a particle
    Particle particle = particles.particle[livePool.indices[idx]];

    // vertex write
    vec3 instance_pos = particle.pos.xyz;
    mat4 billboardMat = billboardAlongVelocity(particle.vel.xyz, ubo.cameraPos.xyz);
    float clamped_speed = clamp(length(particle.vel.xyz), 0, 4) / 4;

    float lifeAlpha = 1 - particle.pos.w / particle.ext.x;
    vec4 colorOverLife = texture(texSampler, vec2((0.5 * (lifeAlpha) * 127)/128, 0.75));
    float intensityOverLife = texture(texSampler, vec2((0.5 * (lifeAlpha) * 127)/128, 0.25)).b;

    vec3 color = particle.color.rgb *pow(2,intensityOverLife) * colorOverLife.rgb * colorOverLife.a;
    per_primitive_out[thread_id*2 + 0].color = color;
    per_primitive_out[thread_id*2 + 1].color = color;

    for(uint i = 0; i < 4; i++)
    {
        vec4 modelPosition = billboardMat *  ubo.model * vec4(vertices[i] * vec3(0.2,0.2,0.2) * vec3(0.1, speed_y_curve(clamped_speed), 1),1.0);
        gl_MeshVerticesNV[i + 4*thread_id].gl_Position = ubo.proj * ubo.view * (vec4(modelPosition.xyz + instance_pos, 1.0));
        
        v_out[i + 4*thread_id].fragTexCoord = uvs[i];
    }

    for(uint i = 0; i < 6; i++)
    {
        gl_PrimitiveIndicesNV[i + 6*thread_id] = 4*thread_id + indices[i];
    }
    
    if (thread_id == 0) {
        gl_PrimitiveCountNV = LOCAL_SIZE * 2;
        if((gl_WorkGroupID.x + 1) * LOCAL_SIZE > drawIndirect.content[0].instanceCount)
        {
            gl_PrimitiveCountNV = max(drawIndirect.content[0].instanceCount - gl_WorkGroupID.x * LOCAL_SIZE, 0);
        }
    }
}
